# The Basics

### install Type Script

```bash
npm install -g typescript
```

> This installs the TypeScript Compiler tsc globally. You can use npx or similar tools if you’d prefer to run tsc from a local node_modules package instead


### tsc

We can compile our TypeScript file to JavaScript with ``tsc app.ts`` command.

### noEmitOnError


you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the **noEmitOnError** compiler option. Try changing your ``hello.ts`` file and running ``tsc`` with that flag:

```sh
tsc --noEmitOnError hello.ts
```
### Explicit Types
we don’t always have to write explicit type annotations. In many cases, TypeScript can even just infer (or “figure out”) the types for us even if we omit them.

```ts
let msg = "hello there!";
    
//let msg: string
```
Even though we didn’t tell TypeScript that msg had the type string it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.
### Static type-checking
Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.
```ts
const message = "hello!";

message();
//This expression is not callable.
//Type 'String' has no call signatures.
```
Running that last sample with TypeScript will give us an error message before we run the code in the first place.
### Non-exception Failures
The specification says that trying to call something that isn’t callable should throw an error. a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error.
```ts
const user = {
  name: "Daniel",
  age: 26,
};
 
user.location;
//Property 'location' does not exist on type '{ name: string; age: number; }'.
```