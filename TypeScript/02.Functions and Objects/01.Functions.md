# More on Functions

### Function Type Expressions

The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:

```ts
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}
 
function printToConsole(s: string) {
  console.log(s);
}
 
greeter(printToConsole);
```

The syntax ``(a: string) => void`` means “a function with one parameter, named ``a``, of type string, that doesn’t have a return value”.

>Note that the parameter name is required. The function type (string) => void means “a function with a parameter named string of type any“!

### Call Signatures

 If we want to describe something callable with properties, we can write a call signature in an object type:

 ```ts
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}
 ```
>Note that the syntax is slightly different compared to a function type expression - use ``:`` between the parameter list and the return type rather than ``=>``.

### Generic Functions

It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way.

In TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature:

```ts
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```
By adding a `type` parameter Type to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value).

#### Inference

```ts
function maping<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}
 
// Parameter 'n' is of type 'string'
// 'parsed' is of type 'number[]'
const parsed = maping(["1", "2", "3"], (n) => parseInt(n));
```
Note that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).

#### Constraints

We can use a constraint to limit the kinds of types that a type parameter can accept.

Let’s write a function that returns the longer of two values. To do this, we need a `length` property that’s a number. We constrain the type parameter to that type by writing an `extends` clause:

```ts
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}
 
// longerArray is of type 'number[]'
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString is of type 'alice' | 'bob'
const longerString = longest("alice", "bob");
// Error! Numbers don't have a 'length' property
const notOK = longest(10, 100);

// Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
```

